# Общее описание языка `tipster`

## Введение

**Tipster** — это функционально-логический язык и среда программирования, сочетающие в себе декларативную мощь логических языков (в духе Prolog) и гибкость процедурно-функциональных систем (Clojure/EDN). Его уникальная особенность — **единый синтаксис с двойной семантикой**: каждое выражение одновременно и функция, и логический факт.

**Tipster** возник как ответ на фундаментальную проблему: современные задачи требуют сочетания строгой декларативности (логика, знания, вывод) и мощности процедурной абстракции (алгоритмы, композиция, потоки данных). В отличие от чистых логических языков (Prolog) или чисто функциональных (Clojure), **Tipster** строит мост между этими мирами, делая синтаксис Clojure-совместимым, а семантику — “плавающей”:

* обработка “по-функциональному” приводит к такому же результату, как обычный Clojure-компилятор;
* обработка “по-логическому” даёт вывод в стиле Prolog, но без ограничения на чисто логический стиль.

**Tipster** занимает место между крайностями:

* **Функциональный полюс**: стопроцентная совместимость с Clojure, без ограничения выразительных средств, макросов и процедурных трюков;
* **Логический полюс**: унификация, бэктрекинг, декларативность в стиле Prolog, но без необходимости использовать иной синтаксис или отдельную систему.

> **В результате, программирование на Tipster — это всегда баланс, “семантический сдвиг” между вычислением и утверждением.**

**Зачем нужен Tipster, если уже есть Clojure, Prolog, SQL и Datalog?**

* Tipster даёт интеграцию — можно использовать весь инструментарий Clojure и при этом иметь логическую базу и вывод “по-родному”, а не как “плагин”.
* Нет дублирования кода: любые функции, написанные для Clojure, становятся логическими предикатами и наоборот.
* Это язык для гибридных задач: прототипирование ИИ, моделирование знаний, формализация бизнес-правил, быстрый переход от декларации к вычислению и обратно.

---

## Исторический контекст и сравнение с базовыми языками

### Prolog: чистая декларативность и её пределы

* Программы — наборы фактов и правил, вывод основан на унификации и бэктрекинге.
* Отлично подходит для задач, где модель формулируется в виде “фактов + правил”, но сложно использовать для “алгоритмических” задач и интеграции с современным стеком.
* Tipster сохраняет эту мощь, но устраняет ограничения на синтаксис и процедурные абстракции.

### Lisp / Clojure: мультипарадигменная гибкость

* Гомоиконность, макросистема, функциональные и процедурные паттерны.
* Великолепен для прототипирования, абстракции и работы с потоками данных, но не предназначен для “чисто логических” моделей.
* Tipster берёт в себя всю гибкость Clojure, расширяя её логическим выводом.

### SQL / Datalog: декларативные запросы

* Ориентированы на работу с реляционными данными, декларативны, но ограничены таблицами, схемами, типизацией.
* Не решают задачи, связанные с программированием общего назначения или произвольными структурами данных.
* Tipster можно использовать как Datalog-на-стероидах, где нет необходимости строго придерживаться реляционной схемы.

---

## Двойная семантика выражений: вычисление и утверждение

Любое выражение-предикат в Tipster:

* Может быть вызвано как обычная функция (например, `(integer? 42)`), немедленно вычисляя значение.
* Одновременно трактуется как логический факт для базы знаний.

Это позволяет:

* Использовать всю стандартную библиотеку Clojure для логических выводов.
* Создавать “сквозные” программы, где логика и вычисления не разделены искусственно.

---

## Примеры: факты, правила и смешанные конструкции

**Факт** — всегда вызов предиката над данными:

```clojure
(родитель джон мэри)         ; "Джон — родитель Мэри"
(integer? 42)                ; "42 — целое число"
```

**Правило** — обычная функция, использующая and/or/for/when и любые конструкции Clojure:

```clojure
(defn родитель-старше
  [parent child]
  (and
    (родитель parent child)
    (>
      (возраст parent p-age)
      (возраст child c-age))))
```

**Фильтрация результата** (пример с for):

```clojure
(defn совершеннолетний-родитель [x]
  (for [(родитель x y)
        (возраст x age)
        :when (>= age 18)]
    x))
```

Или с and:

```clojure
(defn совершеннолетний-родитель [x y]
  (and
    (родитель x y)
    (возраст x age)
    (>= age 18)
    {:родитель x :ребёнок y :возраст age}))
```

**Приведение результата к структуре:**

* Просто возвращаете map, vector, record — всё работает и на стороне логики, и на стороне функций.

---

## Архитектура: компилятор и runtime

1. **Компилятор Tipster**

   * Преобразует Clojure/EDN-код с логическими расширениями в оптимальный байткод и схемы логического вывода.
   * Не требует изменений в исходном синтаксисе.

2. **Runtime-сервер**

   * Хранит факты и правила, реализует унификацию, бэктрекинг и ленивые потоки результатов.
   * Полностью совместим с Clojure-экосистемой.

**Программист работает только с Clojure/EDN — вся сложность скрыта за компилятором и сервером.**

---

## Сравнение с альтернативами

| Язык/технология        | Функциональность | Логическая мощь | Гибкость | Применимость к данным | Интеграция |
| ---------------------- | ---------------- | --------------- | -------- | --------------------- | ---------- |
| **Prolog**             | —                | +++             | —        | —                     | —          |
| **Lisp/Clojure**       | +++              | —               | +++      | ++                    | +++        |
| **Datalog/core.logic** | ++               | ++              | +        | ++                    | ++         |
| **Tipster**            | +++              | +++             | +++      | +++                   | +++        |

---

## Пример полного модуля

```clojure
(ns tipster.examples.family
  (:require [tipster.engine :as logic]))

(def facts
  [[:parent :john :mary]
   [:parent :john :sue]
   [:parent :mary :bob]])
(logic/load-facts! facts)

(defn ancestor
  [x y]
  (lazy-cat
    (logic/query-facts :parent [x y])
    (for [z (logic/query-facts :parent [x nil])
          [_ y2] (ancestor z y)]
      [x y])))

(defn siblings
  [x y]
  (for [[_ p] (logic/query-facts :parent [nil x])
        [x1 _] (logic/query-facts :parent [x  p])
        [y1 _] (logic/query-facts :parent [y  p])
        :when (not= x1 y1)]
    {:sibs [x1 y1]}))
```

---

## Преимущества и компромиссы

| Преимущества                                        | Компромиссы                                         |
| --------------------------------------------------- | --------------------------------------------------- |
| ✔️ Полная нативность Clojure/EDN                    | ✖️ Требуется кастомный компилятор и runtime         |
| ✔️ Гибрид логики и функции                          | ✖️ Отладка логической части требует tooling         |
| ✔️ Унификация и бэктрекинг без дублирования         | ✖️ Требует соглашения о “чистоте” предикатов        |
| ✔️ Совместимость с экосистемой                      | ✖️ Интеграция с не-EDN/Java-кодом требует адаптеров |
| ✔️ Ленивая обработка и интеграция с потоками данных |                                                     |

---

## Заключение

**Tipster** — это универсальный инструмент для гибридного программирования, объединяющий лучшие идеи Prolog, Lisp и SQL, но реализованный “на языке Clojure”, без потери выразительности и архитектурной целостности. Он позволяет одновременно строить декларативные модели и использовать всю мощь современного функционального программирования, скрывая сложность логического вывода за простым, нативным синтаксисом.

---

### *P.S.*

Если вы знакомы с Clojure, вы уже на 90% знаете синтаксис Tipster. Если работали с Prolog или SQL — вся логика покажется естественной. Главное отличие — в Tipster нет необходимости выбирать между вычислением и утверждением: **оба подхода работают совместно и усиливают друг друга**.

---

[**Общее описание языка Tipster**](docs/ru/general_description_ru.md)

