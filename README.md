# Общее описание языка `tipster`

## Введение

Для того, чтобы понять суть языка `Tipster`, проведем некоторый экскурс в такие языки как `Prolog`, `Lisp` и `SQL` потому, что типстер обладает свойствами всех перечисленных языков.

### Prolog

**Prolog (Programming in Logic)** — декларативный логический язык программирования, где программа описывается набором **фактов и правил**, а вычисление сводится к **унификации термов** и систематическому **поиску с возвратом** для вывода истинности запросов; применяется прежде всего в задачах логического вывода знаний, экспертных системах и ограниченном программировании.

Пролог, использует логику первого порядка, которая подразумевает конструктивный подход к доказательству, поэтому все программирование на этом языке находится в состоянии постоянного риска натолкнуться на цель, которая достижима только при использовании **индукционного перехода** либо вообще не достижима -- это фундаментальная математическая проблема. Если к этому прибавить технологические ограничения, экономические, организационные и прочие факторы, то Пролог стал уделом узких специалистов, но все же он остаётся лучшим инструментом, когда **исходная модель** уже формулируется в виде **фактов + правил**.
В итоге пролог закрепился в следующих нишах:  
* **CLP / CP-решатели** — ECLiPSe, SICStus, B-Prolog: планирование, расписания, логистика, а также типовые комбинаторные оптимизации (TSP, bin-packing, allocation)   
* **Компиляторы и языковые процессоры** — DCG-парсеры, генераторы кода и трансформации AST (SWI-Prolog, Logtalk)   
* **Статический анализ и формальная верификация** — ProB, специализированные анализаторы UML/CFG, model-checking и property-based-тесты   
* **Встроенные rule-движки** — Drools/BRMS, Amzi Logic Server, логические плагины PostgreSQL, ядро IBM Watson; бизнес-правила и экспертные системы   
* **NLP и семантические знания** — DCG-грамматики, парсеры, SWRL/Datalog reasoning поверх OWL/RDF   
* **Исследования и обучение** — демонстрация теорем, академические курсы логического программирования, экспериментальные DSL.

На мой взгляд поэтому Пролог так и не был коммерциолизирован и, соответственно, остался уделом узких специалистов.

### SQL

**SQL (Structured Query Language)** — декларативный язык запросов, предназначенный для создания, модификации и управления данными в **реляционных базах данных (РБД)**, где пользователь описывает **какие данные** ему нужны, а система управления базами данных (СУБД) самостоятельно определяет **оптимальный способ** их извлечения на основе **плана запроса**; применяется повсеместно для хранения, обработки и анализа структурированных данных.

SQL основан на **реляционной алгебре** и **реляционном исчислении**, что обеспечивает ему строгую математическую базу и позволяет эффективно работать с **данными, представленными в виде таблиц (отношений)**. Его декларативность избавляет разработчика от необходимости описывать низкоуровневые процедуры доступа к данным. Однако, это же может приводить к неоптимальным запросам, если разработчик не до конца понимает **внутренние механизмы работы СУБД** и принципы **оптимизации запросов**. Если к этому добавить различия в диалектах SQL у разных вендоров и сложность работы с нереляционными или слабоструктурированными данными (хотя JSON/XML поддержка расширяется), то эффективное использование SQL требует глубоких знаний. Тем не менее, он остаётся лучшим инструментом, когда **исходная модель данных** естественным образом представляется в виде **таблиц со связями**.

SQL несёт в себе ряд системных ограничений, которые приходится учитывать архитекторам и разработчикам:

* **Трёхзначная логика `NULL`** осложняет эквивалентные преобразования и вызывает «ломкие» предикаты (`NULL ≠ NULL`).
* **Impedance mismatch** между императивным кодом и декларативной моделью (отсутствие циклов, различие типов, нюансы транзакций) порождает целые классы ORM-фреймворков и хранимых процедур.
* **Выход за 1-нормальную форму** (JSON, массивы, графы) приводит к диалектным расширениям и снижению переносимости; стандарт SQL:2023 только частично нивелирует расхождение.
* **Сложные запросы** — рекурсивные CTE, оконные функции, большие `JOIN`-графы — могут иметь экспоненциальную стоимость, а кардинальности не всегда прогнозируемы оптимизатором.

В результате SQL занял устойчивые и разноформатные ниши:

* **OLTP-СУБД** — PostgreSQL, MySQL, Oracle, SQL Server: транзакционные системы, финучёт, CRM/ERP.
* **Колонковые и MPP-хранилища (OLAP/DWH)** — Snowflake, BigQuery, Redshift, ClickHouse: аналитические витрины, отчётность, ad-hoc-запросы.
* **Потоковые движки** — Flink SQL, ksqlDB, Materialize: near-real-time обработка событий, CDC, онлайн-мониторинг.
* **Встроенные решения** — SQLite, DuckDB: мобильные и desktop-приложения, edge-аналитика, локальные эксперименты.
* **BI / self-service-аналитика** — Looker, Superset, Power BI: визуализация, дашборды, интерактивные запросы поверх lakehouse.
* **Data-engineering / ELT** — dbt, Apache Spark SQL, Airbyte: трансформации, очистка данных, оркестрация пайплайнов.
* **Расширенные домены** — PostGIS (GIS-аналитика), TimescaleDB (time-series), PGVector / Milvus (векторный поиск), гибридные графовые расширения (Cypher-, GQL-подмножества).
* **Стандартизация и обучение** — ISO/IEC 9075-:2023, курсы реляционной теории, исследовательские проекты по оптимизации планов и формальной верификации.

На мой взгляд, SQL — редкий пример декларативного языка, который полностью коммерциализирован и стал отраслевым стандартом доступа к данным. Масштабируемость и зрелость экосистемы компенсируют его исторические компромиссы, но требуют дисциплины: чёткой схемы, разумной нормализации, продуманной индексации и строгого разделения слоёв (запрос ↔ приложение). Именно эта инженерная строгость позволяет опираться на SQL как на базовый инструмент организации корпоративных и облачных данных.

### Lisp

**Lisp (LISt Processing)** — мультипарадигменный (часто функциональный) язык программирования, где программа и данные представляются в виде **списочных структур (S-выражений)**, а вычисление сводится к **редукции выражений** и **применению функций** с активным использованием **рекурсии** и **REPL (Read-Eval-Print Loop)**; применяется прежде всего в задачах **символьных вычислений**, искусственного интеллекта, прототипирования и создания **DSL (предметно-ориентированных языков)**.

Lisp, с его **гомоиконностью** (код как данные) и мощной **макросистемой**, позволяет программисту эффективно расширять язык и создавать **предметно-ориентированные языки (DSL)**, идеально подходящие для конкретной задачи. Эта уникальная мощь позволяет решать сложные проблемы элегантно и с высокой степенью абстракции. Однако, эта же гибкость, высокий порог вхождения для освоения всех возможностей (особенно макросов и функционального стиля), а также исторически сложившаяся репутация "языка для академиков" или "языка со слишком большим количеством скобок" привели к тому, что Lisp, несмотря на свою мощь и влияние (многие его концепции, такие как сборка мусора, условные выражения, REPL, вошли в мейнстрим), остался инструментом для энтузиастов и специалистов в определенных областях. Тем не менее, Lisp остаётся непревзойденным, когда требуется **быстрое прототипирование сложных систем**, **глубокая метапрограммная настройка** или **обработка символьной информации**.

В итоге Lisp (и его диалекты, такие как Common Lisp, Scheme, Clojure, Emacs Lisp) закрепился в следующих нишах:
*   **AI и символьные вычисления** — ACL2 (формальная верификация теорем), Cyc (представление знаний), Maxima/Reduce (системы компьютерной алгебры), ранние экспертные системы.
*   **Создание DSL и расширяемых систем** — Racket (языково-ориентированное программирование), Emacs (текстовый редактор и среда, расширяемая на Emacs Lisp), AutoCAD (AutoLISP для автоматизации проектирования).
*   **Быстрое прототипирование и разработка** — Common Lisp, Scheme, Clojure для создания сложных приложений, где важна гибкость и скорость итераций.
*   **Веб-разработка и серверные приложения (современные диалекты)** — Clojure (высокопроизводительные, конкурентные системы, работа с данными), некоторые фреймворки на Common Lisp (например, Hunchentoot).
*   **Образование и исследования** — Преподавание фундаментальных концепций программирования (SICP на Scheme), исследование новых парадигм и языковых конструкций.
*   **Графика, музыка и искусство** — OpenMusic, PWGL (визуальные языки программирования на базе Common Lisp для алгоритмической композиции), генеративное искусство.
*   **Финансовый анализ и торговые системы** — некоторые компании используют Lisp и его диалекты для разработки проприетарных систем анализа данных и алгоритмической торговли благодаря его выразительности и способности к быстрой адаптации.

На мой взгляд, именно высокий порог вхождения, специфичность задач, где его мощь раскрывается в полной мере, и фрагментация на множество диалектов не позволили Lisp стать таким же мейнстримом, как, например, Java или Python, оставив его уделом энтузиастов и специалистов в своих нишах, ценящих его уникальные возможности.
