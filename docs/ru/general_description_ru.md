# Общее описание языка `tipster`

## Введение

**Tipster** — новый язык и среда, сочетающие декларативную мощь Пролога с привычным синтаксисом Clojure/EDN и процедурными расширениями Lisp. Программист работает только с функциями и EDN-данными, а под капотом компилятор превращает их в логический движок с бэктрекингом и унификацией.

Главная идея:

* **Если обработать на Tipster классическую Clojure-программу**, результат будет идентичен выводу стандартного Clojure-компилятора. То есть, Tipster полностью сохраняет и развивает функциональную парадигму — с чистыми функциями, рекурсией, высшими функциями, макросами и всей экосистемой.
* **Если же взять логическую программу (например, код, портированный с Prolog) и обработать её Tipster-компилятором**, то результат будет эквивалентен классическому логическому выводу: на выходе — решение задачи логического программирования с унификацией, бэктрекингом и декларативной формулировкой знаний в виде "фактов + правил".

Таким образом, **Tipster** — это язык с двумя полюсами:

* **Крайность в сторону функционального программирования**: 100% совместим с Clojure, не добавляет новых форм, не навязывает иной семантики.
* **Крайность в сторону логического программирования**: позволяет описывать знания и правила в духе Prolog, но на чистом синтаксисе EDN/Clojure, делая логический вывод и работу с фактами "родной" частью экосистемы Clojure.

На практике программирование на Tipster обычно находится **где-то между этими крайностями**. Вы можете совмещать декларативные логические правила с функциональными абстракциями, добиваясь оптимального баланса выразительности и управляемости — именно в этом проявляется сила и уникальность языка Tipster.

**Tipster — это не просто синтаксическая надстройка или транспайлер, а новый универсальный инструмент, который одинаково естественно поддерживает обе парадигмы**. Его компилятор прозрачно превращает Clojure-код в обычный функциональный байткод, а логические конструкции — в эффективные логические схемы и runtime-запросы, реализуя в едином проекте и функции, и логический вывод, и работу с данными в стиле SQL.


Для того, чтобы понять суть, проведем некоторый экскурс в такие языки как `Prolog`, `Lisp` и `SQL` потому, что типстер обладает свойствами всех перечисленных языков.

### Prolog

**Prolog (Programming in Logic)** — гомоиконный декларативный логический язык программирования, где программа описывается набором **фактов и правил**, а вычисление сводится к **унификации термов** и систематическому **поиску с возвратом** для вывода истинности запросов; применяется прежде всего в задачах логического вывода знаний, экспертных системах и ограниченном программировании.

Пролог, использует логику первого порядка, которая подразумевает конструктивный подход к доказательству, поэтому все программирование на этом языке находится в состоянии постоянного риска натолкнуться на цель, которая достижима только при использовании **индукционного перехода** либо вообще не достижима -- это фундаментальная математическая проблема. Если к этому прибавить технологические ограничения, экономические, организационные и прочие факторы, то Пролог стал уделом узких специалистов, но все же он остаётся лучшим инструментом, когда **исходная модель** уже формулируется в виде **фактов + правил**.
В итоге пролог закрепился в следующих нишах:  
* **CLP / CP-решатели** — ECLiPSe, SICStus, B-Prolog: планирование, расписания, логистика, а также типовые комбинаторные оптимизации (TSP, bin-packing, allocation)   
* **Компиляторы и языковые процессоры** — DCG-парсеры, генераторы кода и трансформации AST (SWI-Prolog, Logtalk)   
* **Статический анализ и формальная верификация** — ProB, специализированные анализаторы UML/CFG, model-checking и property-based-тесты   
* **Встроенные rule-движки** — Drools/BRMS, Amzi Logic Server, логические плагины PostgreSQL, ядро IBM Watson; бизнес-правила и экспертные системы   
* **NLP и семантические знания** — DCG-грамматики, парсеры, SWRL/Datalog reasoning поверх OWL/RDF   
* **Исследования и обучение** — демонстрация теорем, академические курсы логического программирования, экспериментальные DSL.

На мой взгляд поэтому Пролог так и не был коммерциолизирован и, соответственно, остался уделом узких специалистов.

### SQL

**SQL (Structured Query Language)** — декларативный язык запросов, предназначенный для создания, модификации и управления данными в **реляционных базах данных (РБД)**, где пользователь описывает **какие данные** ему нужны, а система управления базами данных (СУБД) самостоятельно определяет **оптимальный способ** их извлечения на основе **плана запроса**; применяется повсеместно для хранения, обработки и анализа структурированных данных.

SQL основан на **реляционной алгебре** и **реляционном исчислении**, что обеспечивает ему строгую математическую базу и позволяет эффективно работать с **данными, представленными в виде таблиц (отношений)**. Его декларативность избавляет разработчика от необходимости описывать низкоуровневые процедуры доступа к данным. Однако, это же может приводить к неоптимальным запросам, если разработчик не до конца понимает **внутренние механизмы работы СУБД** и принципы **оптимизации запросов**. Если к этому добавить различия в диалектах SQL у разных вендоров и сложность работы с нереляционными или слабоструктурированными данными (хотя JSON/XML поддержка расширяется), то эффективное использование SQL требует глубоких знаний. Тем не менее, он остаётся лучшим инструментом, когда **исходная модель данных** естественным образом представляется в виде **таблиц со связями**.

SQL несёт в себе ряд системных ограничений, которые приходится учитывать архитекторам и разработчикам:

* **Трёхзначная логика `NULL`** осложняет эквивалентные преобразования и вызывает «ломкие» предикаты (`NULL ≠ NULL`).
* **Impedance mismatch** между императивным кодом и декларативной моделью (отсутствие циклов, различие типов, нюансы транзакций) порождает целые классы ORM-фреймворков и хранимых процедур.
* **Выход за 1-нормальную форму** (JSON, массивы, графы) приводит к диалектным расширениям и снижению переносимости; стандарт SQL:2023 только частично нивелирует расхождение.
* **Сложные запросы** — рекурсивные CTE, оконные функции, большие `JOIN`-графы — могут иметь экспоненциальную стоимость, а кардинальности не всегда прогнозируемы оптимизатором.

В результате SQL занял устойчивые и разноформатные ниши:

* **OLTP-СУБД** — PostgreSQL, MySQL, Oracle, SQL Server: транзакционные системы, финучёт, CRM/ERP.
* **Колонковые и MPP-хранилища (OLAP/DWH)** — Snowflake, BigQuery, Redshift, ClickHouse: аналитические витрины, отчётность, ad-hoc-запросы.
* **Потоковые движки** — Flink SQL, ksqlDB, Materialize: near-real-time обработка событий, CDC, онлайн-мониторинг.
* **Встроенные решения** — SQLite, DuckDB: мобильные и desktop-приложения, edge-аналитика, локальные эксперименты.
* **BI / self-service-аналитика** — Looker, Superset, Power BI: визуализация, дашборды, интерактивные запросы поверх lakehouse.
* **Data-engineering / ELT** — dbt, Apache Spark SQL, Airbyte: трансформации, очистка данных, оркестрация пайплайнов.
* **Расширенные домены** — PostGIS (GIS-аналитика), TimescaleDB (time-series), PGVector / Milvus (векторный поиск), гибридные графовые расширения (Cypher-, GQL-подмножества).
* **Стандартизация и обучение** — ISO/IEC 9075-:2023, курсы реляционной теории, исследовательские проекты по оптимизации планов и формальной верификации.

На мой взгляд, SQL — редкий пример декларативного языка, который полностью коммерциализирован и стал отраслевым стандартом доступа к данным. Масштабируемость и зрелость экосистемы компенсируют его исторические компромиссы, но требуют дисциплины: чёткой схемы, разумной нормализации, продуманной индексации и строгого разделения слоёв (запрос ↔ приложение). Именно эта инженерная строгость позволяет опираться на SQL как на базовый инструмент организации корпоративных и облачных данных.

### Lisp

**Lisp (LISt Processing)** — мультипарадигменный (часто функциональный) язык программирования, где программа и данные представляются в виде **списочных структур (S-выражений)**, а вычисление сводится к **редукции выражений** и **применению функций** с активным использованием **рекурсии** и **REPL (Read-Eval-Print Loop)**; применяется прежде всего в задачах **символьных вычислений**, искусственного интеллекта, прототипирования и создания **DSL (предметно-ориентированных языков)**.

Lisp, с его **гомоиконностью** (код как данные) и мощной **макросистемой**, позволяет программисту эффективно расширять язык и создавать **предметно-ориентированные языки (DSL)**, идеально подходящие для конкретной задачи. Эта уникальная мощь позволяет решать сложные проблемы элегантно и с высокой степенью абстракции. Однако, эта же гибкость, высокий порог вхождения для освоения всех возможностей (особенно макросов и функционального стиля), а также исторически сложившаяся репутация "языка для академиков" или "языка со слишком большим количеством скобок" привели к тому, что Lisp, несмотря на свою мощь и влияние (многие его концепции, такие как сборка мусора, условные выражения, REPL, вошли в мейнстрим), остался инструментом для энтузиастов и специалистов в определенных областях. Тем не менее, Lisp остаётся непревзойденным, когда требуется **быстрое прототипирование сложных систем**, **глубокая метапрограммная настройка** или **обработка символьной информации**.

В итоге Lisp (и его диалекты, такие как Common Lisp, Scheme, Clojure, Emacs Lisp) закрепился в следующих нишах:
*   **AI и символьные вычисления** — ACL2 (формальная верификация теорем), Cyc (представление знаний), Maxima/Reduce (системы компьютерной алгебры), ранние экспертные системы.
*   **Создание DSL и расширяемых систем** — Racket (языково-ориентированное программирование), Emacs (текстовый редактор и среда, расширяемая на Emacs Lisp), AutoCAD (AutoLISP для автоматизации проектирования).
*   **Быстрое прототипирование и разработка** — Common Lisp, Scheme, Clojure для создания сложных приложений, где важна гибкость и скорость итераций.
*   **Веб-разработка и серверные приложения (современные диалекты)** — Clojure (высокопроизводительные, конкурентные системы, работа с данными), некоторые фреймворки на Common Lisp (например, Hunchentoot).
*   **Образование и исследования** — Преподавание фундаментальных концепций программирования (SICP на Scheme), исследование новых парадигм и языковых конструкций.
*   **Графика, музыка и искусство** — OpenMusic, PWGL (визуальные языки программирования на базе Common Lisp для алгоритмической композиции), генеративное искусство.
*   **Финансовый анализ и торговые системы** — некоторые компании используют Lisp и его диалекты для разработки проприетарных систем анализа данных и алгоритмической торговли благодаря его выразительности и способности к быстрой адаптации.

На мой взгляд, именно высокий порог вхождения, специфичность задач, где его мощь раскрывается в полной мере, и фрагментация на множество диалектов не позволили Lisp стать таким же мейнстримом, как, например, Java или Python, оставив его уделом энтузиастов и специалистов в своих нишах, ценящих его уникальные возможности.


### Tipster: EDN-диалект функционально-логического программирования на базе Clojure

---

#### 1. Контраст с Прологом

| Пролог                                 | Tipster                                    |
|----------------------------------------|--------------------------------------------|
| Вызов предиката инициализирует переменные в аргументах и возвращает набор подстановок. | Вызов функции-правила _не_ меняет аргументы — всегда возвращает ленивую `seq` конкретных EDN-фактов/структур. |
| Факты и правила хранятся в одном пространстве иявляются частью языка. | Факты и правила компилируются в runtime-БД; программист не обращается к ней явно. |
| Специальные формы `:-`, `?-`, приставки для переменных. | Нет «спец-форм»: всё — чистый Clojure/EDN. |

---

#### 2. Факты как EDN-данные

Любой EDN-литерал или структура — _готовый факт_; в нём **не** может быть переменных:

```clojure
;; Примитивы
42
"hello"
true
nil

;; Составные
[:parent :john :mary]
'(:likes :alice :chocolate)
{:person {:id 42 :name "Alice"}}
#{:red :green :blue}
```

> **Замечание.** Факты загружаются компилятором в internal runtime-БД (через DSL-блок или `load-facts!`), но программный код их не читает напрямую.

---

#### 3. Правила как функции

Правило объявляется обычным `defn`. Параметры и локальные переменные — чистые Clojure-символы. Результат вызова — ленивый `seq` конкретизированных фактов:

```clojure
(ns tipster.examples.family
  (:require [tipster.engine :as logic]))

;; Правило-предикат
(defn ancestor
  "Ищет всех предков y для заданного x."
  [x y]
  (lazy-cat
    ;; Прямой факт
    (logic/query-facts :parent [x y])

    ;; Рекурсивный поиск: z — просто локальная переменная
    (for [z   (logic/query-facts :parent [x nil])
          [_ y2] (ancestor z y)]
      [x y])))
```

* **`logic/query-facts`** — вызов runtime-API, сгенерированного компилятором, вытягивает факты из БД.
* **`lazy-cat`, `for`** — стандартные Clojure-формы, в которые компилятор встраивает бэктрекинг.

---

#### 4. Результат логического вывода

* **Тип**: ленивый `seq` EDN-структур (векторов, карт или любых обёрток по соглашению).
* **Готовые данные**: все поля конкретны, без «незаполненных» переменных.

```clojure
;; Пример вызова
(ancestor :john nil)
;; => ([:john :mary] [:john :sue] [:john :bob] …)
```

В более сложных правилах можно возвращать карты:

```clojure
(defn siblings
  [x y]
  (for [[_ p]   (logic/query-facts :parent [nil x])
        [x1 _]  (logic/query-facts :parent [x  p])
        [y1 _]  (logic/query-facts :parent [y  p])
        :when   (not= x1 y1)]
    {:sibs [x1 y1]}))
```

---

#### 5. Архитектура: компилятор и runtime-сервер

1. **Компилятор Tipster**

   * Парсит Clojure-файлы, выделяет `defn`-правила и EDN-факты.
   * Генерирует код с внутренними вызовами `logic/query-facts`, индексами, планом унификации и бэктрекинга.

2. **Runtime-сервер**

   * Хранит факты и оптимизированные структуры правил.
   * Отвечает на сгенерированные компилятором запросы, возвращая ленивые потоки результатов.

> **Программист** видит только Clojure-код и EDN — всю «магическую» логику скрывает компиляция и сервер.

---

#### 6. Преимущества и компромиссы

| Плюсы                                                            | Компромиссы                                              |
| ---------------------------------------------------------------- | -------------------------------------------------------- |
| ✔️ Полная нативность Clojure/EDN — нет новых форм и приставок    | ✖️ Необходим кастомный компилятор и отдельный runtime    |
| ✔️ Встроенный бэктрекинг и унификация, без явного управления     | ✖️ Отладка генерированного кода требует инструментов IDE |
| ✔️ Процедурные расширения: макросы, I/O, функции высшего порядка | ✖️ Может потребоваться соглашения о «чистоте» предикатов |
| ✔️ Ленивый `seq` упрощает интеграцию с экосистемой Clojure       |                                                          |

---

#### 7. Пример полного модуля

```clojure
(ns tipster.examples.family
  (:require [tipster.engine :as logic]))

;; —————————————————————————
;; 1. Факты (EDN)
(def facts
  [[:parent :john :mary]
   [:parent :john :sue]
   [:parent :mary :bob]])
(logic/load-facts! facts)

;; —————————————————————————
;; 2. Правила (defn)
(defn ancestor
  [x y]
  (lazy-cat
    (logic/query-facts :parent [x y])
    (for [z   (logic/query-facts :parent [x nil])
          [_ y2] (ancestor z y)]
      [x y])))

(defn siblings
  [x y]
  (for [[_ p]   (logic/query-facts :parent [nil x])
        [x1 _]  (logic/query-facts :parent [x  p])
        [y1 _]  (logic/query-facts :parent [y  p])
        :when   (not= x1 y1)]
    {:sibs [x1 y1]}))

;; —————————————————————————
;; 3. Запросы (REPL)
;; (ancestor :john nil)
;; => ([:john :mary] [:john :sue] [:john :bob] …)
;; (siblings :mary nil)
;; => ({:sibs [:john :mary]} {:sibs [:mary :bob]} …)
```

---

#### Заключение

Tipster предоставляет **однородный** синтаксис Clojure/EDN для логического программирования, скрывая сложность унификации и бэктрекинга за компилятором и runtime-сервером. Вы получаете декларативную выразительность Пролога и процедурную гибкость Lisp, сохраняя архитектурную целостность и масштабируемость.


