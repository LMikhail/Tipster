# Обоснование проектных решений в Tipster Core

## Сводная таблица решений

| Концепция | Ключевое преимущество (За) | Основной компромисс (Против) | Оценка веса решения |
| :--- | :--- | :--- | :--- |
| **Суперсет Clojure** | Огромная экономия сил за счет переиспользования экосистемы. | Высокий порог входа для не-Clojure разработчиков. | `++` (Стратегически верное) |
| **`Symbol` вместо `Atom`** | Устранение критической путаницы с `clojure.core/Atom`. | Незначительная непривычность для Prolog-ветеранов. | `+` (Прагматично и необходимо) |
| **Двойная семантика** | Унификация логики и вычислений в одной конструкции. | Высокая когнитивная нагрузка на разработчика. | `++` (Рискованно, но это ядро инновации) |
| **`def` vs `defn`** | Четкое семантическое разделение данных и логики. | Нарушение "чистоты" Prolog, где факт - частный случай правила. | `+` (Улучшение читаемости) |
| **Модификатор `::l`** | Элегантность и возможность перегрузки имен. | Риск случайной ошибки (забыть `::l`). | `~` (Элегантный компромисс) |
| **Модификаторы вызова** | Максимальный контроль и ясность намерений в коде. | Небольшой синтаксический шум. | `++` (Ключ к гибкости) |
| **Расширяемость** | Легкость добавления новых стратегий вычисления. | Потенциальное усложнение языка в будущем. | `+` (Полезный задел на будущее) |

---

## Подробный разбор решений

Ниже приводится подробное описание каждого решения с аргументами "за" и "против", которые были кратко изложены в таблице выше.

### 1. Tipster как бесшовный суперсет Clojure

**Концепция:** Вместо создания нового языка с нуля, Tipster расширяет Clojure, добавляя в него конструкции логического программирования.

#### За (Pros)

*   **Переиспользование экосистемы:** Позволяет использовать весь богатый набор библиотек, инструментов и существующей кодовой базы Clojure.
*   **Низкий порог входа для Clojure-разработчиков:** Программистам, знакомым с Clojure, не нужно учить совершенно новый синтаксис.
*   **Полная совместимость:** Обеспечивает естественное и бесшовное взаимодействие между декларативным логическим кодом и стандартным функциональным/императивным кодом Clojure.

#### Против (Cons)

*   **Высокий порог входа для "не-Clojure" разработчиков:** Программистам из мира Prolog или других языков придется сначала освоить основы Clojure.
*   **Риск семантических конфликтов:** Необходимо очень тщательно спроектировать компилятор, чтобы новые конструкции не конфликтовали с существующей семантикой Clojure и не приводили к неожиданному поведению.

### 2. Терминология: `Symbol` вместо `Atom`

**Концепция:** Для обозначения уникальных символьных констант (аналог `atom` в Prolog) используется термин и тип `Symbol` из Clojure, а термин `Atom` сознательно избегается.

#### За (Pros)

*   **Устранение путаницы:** Однозначно решает известную проблему омонимии между `atom` в Prolog (константа) и `Atom` в Clojure (ссылочный тип для управления состоянием).
*   **Идиоматичность:** Использование `Symbol` для идентификаторов полностью соответствует духу и практике Clojure.

#### Против (Cons)

*   **Непривычность для Prolog-программистов:** Ветеранам логического программирования может потребоваться время, чтобы привыкнуть к новой терминологии.

### 3. Двойная семантика термов

**Концепция:** Любой терм `(f t₁ ... tₙ)` может быть интерпретирован и как логический паттерн для поиска (`Φ_L`), и как вычислительное выражение для исполнения (`Φ_C`).

#### За (Pros)

*   **Выразительная сила:** Это ключевая инновация, которая унифицирует миры логики и вычислений. Один и тот же код может использоваться и для поиска, и для прямого выполнения.
*   **Лаконичность:** Устраняет необходимость в "коде-клее" для вызова функций из логических правил и наоборот.

#### Против (Cons)

*   **Высокая когнитивная нагрузка:** Концепция может быть сложной для понимания. Разработчик должен четко осознавать, какая интерпретация активна в данный момент, чтобы избежать трудноуловимых ошибок.
*   **Сложность компилятора:** Реализация компилятора, корректно обрабатывающего обе семантики и переключения между ними, является нетривиальной задачей.

### 4. Разделение `def` (факты) и `defn` (правила/функции)

**Концепция:** Факты (безусловные утверждения) определяются через `def`, а правила и функции (вычислительные абстракции) — через `defn`.

#### За (Pros)

*   **Четкое разделение:** Синтаксис подчеркивает разницу между статичными данными (`def`) и вычислительной логикой (`defn`), что улучшает читаемость.
*   **Соответствие идиомам Clojure:** Использование `def` для определения "данных" и `defn` для определения "поведения" канонично для Clojure.

#### Против (Cons)

*   **Отход от чистоты Prolog:** В "чистом" логическом программировании факты и правила являются лишь частными случаями одного и того же понятия — клаузы предиката. Такое разделение может показаться искусственным.

### 5. Модификатор `::l` для определения правил

**Концепция:** Правило отличается от функции не новым макросом (`defrule`), а модификатором `::l` при определении: `(defn::l ...)`.

#### За (Pros)

*   **Элегантность и минимализм:** Позволяет переиспользовать знакомый макрос `defn`. Аннотация `::l` — это легковесный синтаксический маркер.
*   **Перегрузка имен:** Дает возможность определить правило и оптимизированную функцию с одним и тем же именем, что очень удобно на практике.

#### Против (Cons)

*   **Возможность случайных ошибок:** Разработчик может забыть указать `::l` и вместо правила случайно определить обычную функцию, что приведет к ошибкам во время исполнения, а не компиляции.
*   **Необычный синтаксис:** Для людей, не знакомых с Clojure, использование ключевых слов в качестве аннотаций (`::l`) может показаться странным.

### 6. Явные модификаторы вызова (`::l`, `::f`, `::seq`)

**Концепция:** Семантика вызова (логическая, функциональная) определяется явным модификатором на стороне вызывающего кода.

#### За (Pros)

*   **Максимальная ясность и контроль:** Вызывающий код явно декларирует свое намерение, что устраняет всякую двусмысленность.
*   **Прагматичность `::seq`:** Модификатор `::seq` является отличным прагматичным решением, которое материализует ленивую последовательность решений в обычную коллекцию Clojure, готовую для дальнейшей обработки стандартными функциями.
*   **Гибкость:** Позволяет смешивать парадигмы наиболее гибким способом из всех возможных.

#### Против (Cons)

*   **Синтаксический "шум":** В коде, где происходит частое переключение между мирами, обилие модификаторов может снизить читаемость.
*   **Повышенная ответственность разработчика:** Необходимо помнить о модификаторах и правилах их применения (например, что `::f` на правиле вернет только одно решение), что увеличивает когнитивную нагрузку.

### 7. Расширяемость через модификаторы

**Концепция:** Архитектура позволяет легко добавлять новые модификаторы (`::fl`, `::lf`) для реализации смешанных стратегий вычисления.

#### За (Pros)

*   **Задел на будущее:** Систему можно легко расширять новыми стратегиями выполнения, не меняя базовый синтаксис языка.
*   **Мощный механизм метапрограммирования:** Открывает возможности для пользователей и разработчиков фреймворка создавать собственные, кастомные семантики вызова.

#### Против (Cons)

*   **Риск избыточной сложности:** Большое количество модификаторов может сделать язык сложным для изучения и использования. Семантика их комбинаций может стать неочевидной. 
