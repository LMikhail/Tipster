# Ключевые концепции Tipster

## 1. Введение

Этот документ закладывает формальный фундамент для ключевых концепций проекта Tipster. Его цель — служить каноническим источником, определяя основные строительные блоки системы с математической и семантической строгостью.

В основе Tipster лежит **компилятор**, который транслирует высокоуровневый декларативный код, написанный как **бесшовный суперсет Clojure**, в эффективный исполняемый код.

## 2. Базовая терминология и структура термов

Во избежание путаницы, возникающей на стыке логического программирования (в духе Prolog) и Clojure, необходимо четко определить базовые термины.

*   **Символ (Symbol):** В Clojure `Symbol` — это идентификатор, который обычно ссылается на что-либо (например, на функцию или переменную). В Tipster, следуя этой семантике, мы используем символы для обозначения функторов, переменных и других логических конструкций. Это понятие наиболее близко к тому, что в Prolog называется **атомом** (atom) — уникальной символьной константой.

*   **Атом (Atom):** В Clojure `Atom` — это специфический ссылочный тип данных, используемый для управления синхронным, не координированным изменением состояния. **В документации Tipster этот термин не используется**, чтобы избежать путаницы с его прологовским омонимом. Для обозначения символьных констант мы используем термин **Символ**.

## 3. Терм

В Tipster, как и в классическом логическом программировании, **терм** — это базовая структура данных.

### Структура терма

Структурно терм может быть одним из трех:

1.  **Константа:** Атомарное (неделимое) значение, которое служит конечной точкой в процессе унификации. Ключевой принцип: константа унифицируется только с точно такой же константой или со свободной переменной. Она не имеет внутренней *логической* структуры, которую унификатор мог бы рекурсивно сопоставлять.

    Поскольку Tipster — суперсет Clojure, константой может быть **любой нативный тип данных Clojure/Java**, который рассматривается как единое целое. Ответственность за проверку их равенства делегируется стандартной функции Clojure `(=)`.

    Примеры констант включают, но не ограничиваются:
    *   **Числа:** `42`, `3.14`, `22/7`
    *   **Строки:** `"hello world"`
    *   **Символы:** `'some-name`
    *   **Ключевые слова (Keywords):** `:some-keyword`
    *   **Булевы значения:** `true`, `false`, а также `nil`
    *   **Даты/время, UUID и другие подобные типы:** `#inst "..."`, `#uuid "..."`

    Важно отметить, что нативные коллекции Clojure (векторы, мапы и т.д.) **не являются** логическими константами, так как они обладают внутренней структурой, релевантной для унификации. Они относятся к категории **составных термов**.

2.  **Переменная:** Символ, который выступает в роли заполнителя (placeholder) и может быть связан с любым другим термом в процессе унификации.

    **Соглашение об именовании:** В Tipster принято ключевое соглашение, идиоматичное для Lisp-подобных языков: **любой свободный (еще не связанный) символ, встреченный в позиции аргумента терма, считается логической переменной.**

    Это означает, что нет необходимости в специальном синтаксисе (таком как префиксы `?` или `_`, или требование заглавных букв, как в Prolog). Компилятор сам определяет, является ли символ переменной, проверяя, имеет ли он уже значение в текущей лексической области видимости.

    *   В терме `(parent "alice" Child)` символ `Child` является переменной, если он не был ранее определен.
    *   В правиле `(defn|l grandparent [x z] (parent x y) (parent y z))` символы `x`, `y`, и `z` являются переменными в пределах этого правила.

3.  **Составной терм (Compound Term):** Структурная единица, которая группирует другие термы. В Tipster, для идиоматичной интеграции с хост-языком, мы разделяем составные термы на две семантические категории:

    *   **Отношения (Списки):** Список в форме `(f t₁ ... tₙ)` используется для представления логических отношений или предикатов. Первый элемент `f` — **функтор** — является символом, именующим отношение. Это "глагол" логического языка.
        *   Пример: `(parent "alice" Child)`

    *   **Структуры данных (Векторы, Мапы, Сеты):** Нативные коллекции Clojure используются для представления структурированных данных. Их "функтором" является сам их тип. Это "существительные" языка.
        *   **Векторы:** `[1 2 Z]` — для упорядоченных данных.
        *   **Мапы:** `{:name "John" :age Age}` — для пар "ключ-значение".
        *   **Сеты:** `#{:red :green :blue}` — для уникальных неупорядоченных элементов.

    Такое разделение позволяет писать код, который является одновременно и мощным логически, и естественным для Clojure-разработчика. Например, можно определить факт об объекте, используя мапу для его данных: `(def (user 1 {:name "Alice" :role :admin}))`.

    Унификация составных термов всегда происходит структурно: система пытается рекурсивно сопоставить их компоненты.

### Двойная семантика терма

Теперь, когда мы определили различные виды термов, мы можем уточнить их ключевую особенность в Tipster — **двойную семантику**. Это означает, что одна и та же синтаксическая конструкция может интерпретироваться либо как **логический образец для сопоставления**, либо как **вычислимое выражение**. Эта двойственность проявляется для разных термов по-разному.

1.  **Логическая интерпретация ($Φ_L$)**: Терм рассматривается как **образец (pattern)**, который используется движком унификации для поиска совпадений в базе знаний. Это основной режим работы внутри логических правил (`defn|l`).
    *   `X` — это переменная для связывания.
    *   `(parent "alice" Child)` — это образец для поиска фактов об отношении `parent`.
    *   `[1 Y]` — это образец для сопоставления с векторами, у которых первый элемент `1`.

2.  **Вычислительная интерпретация ($Φ_C$)**: Терм рассматривается как **выражение Clojure**, которое нужно вычислить, чтобы получить значение. Этот режим используется в обычном коде Clojure, а также может быть явно вызван внутри правил с помощью модификатора `|f`.
    *   `(+ 1 2)` — вычисляется в константу `3`.
    *   `(str "hello" " " "world")` — вычисляется в константу `"hello world"`.

**Применение семантик к типам термов:**

*   **Константы и Переменные:** Для констант (чисел, строк и т.д.) обе интерпретации по сути совпадают: их "вычисление" дает их же самих. Для переменных вычислительная интерпретация означает получение связанного с ними значения.
*   **Отношения (Списки `(f ...)`):** Здесь двойственность наиболее выражена. Терм `(grandparent "alice" X)` в логическом контексте ($Φ_L$) — это **цель для поиска**, а в вычислительном ($Φ_C$) — это **вызов одноименной функции Clojure**.
*   **Структуры данных (Векторы, Мапы, Сеты):** Их основная роль — служить **логическими образцами ($Φ_L$)**. Их "вычислительная интерпретация" ($Φ_C$) сводится к тому, что они являются **литералами данными**. Если их элементы являются вычислимыми выражениями (например, `(* 2 5)`), они вычисляются *до* того, как вся структура используется в качестве логического образца. Например, в правиле терм `[A (* 2 A)]` при `A=5` сначала вычислится в образец `[5 10]`, который затем будет использован для унификации.

## 4. Основной терм (Ground Term)

**Определение:**

**Основной терм** (англ. *Ground Term*) — это терм, **не содержащий переменных**. Такие термы представляют собой конкретные, полностью определенные данные.

*   **Примеры основных термов:** `42`, `"alice"`, `(location "Paris" "France")`, `[10, "ready"]`, `{:status :ok}`.
*   **Примеры неосновных термов** (содержащих переменные): `X`, `(location City "France")`, `[Count, "ready"]`, `{:status Status}`.

Далее в документе, говоря об "истинных термах" в контексте фактов и предикатов, мы будем иметь в виду именно **основные термы**.

## 5. Определение сущностей: `def` и `defn`

Архитектура Tipster элегантно разделяет определения на два типа: **констатации** (`def`) и **вычислительные абстракции** (`defn`).

### Факты (`def`)

**Определение:** **Факт** — это безусловное, декларативное утверждение о том, что некоторое отношение является истинным для данных **основных термов**.

**Реализация в Tipster:** Факт определяется с помощью `def`, аргументом которого является основной терм. Это синтаксически подчеркивает его природу как неизменяемой констатации.

```clojure
(def (parent "alice" "bob"))
(def (parent "alice" "charlie"))
```

### Правила и Функции (`defn`)

**Определение:** И правила, и функции являются **вычислительными абстракциями** — они принимают аргументы и производят результат. Поэтому для их определения используется единый, канонический для Clojure оператор `defn`.

**Реализация в Tipster:** Чтобы компилятор мог отличить правило от функции, используется **модификатор определения `|l`** (logic).

*   `(defn|l ...)` определяет **Правило**. Компилятор преобразует его в многозначную функцию, возвращающую ленивую последовательность решений.
*   `(defn ...)` (без модификатора) определяет стандартную **Функцию** Clojure.

Это позволяет определять предикат и одноименную вычислительную функцию без каких-либо конфликтов:

```clojure
;; ПРАВИЛО (реализация предиката P_grandparent)
(defn|l grandparent [x z]
  (parent x y)
  (parent y z))

;; ФУНКЦИЯ (реализация вычислительной функции C_grandparent)
(defn grandparent [x z]
  (println "Вызвана быстрая проверка!")
  ; ... код быстрой проверки по графу в памяти ...
)
```

## 6. Вызов и взаимодействие миров

Ключевая инновация Tipster — управление семантикой вызова через **явные модификаторы**. Поскольку Tipster — это суперсет Clojure, нет нужды в специальных "шлюзах" или API. Любая сущность может быть вызвана из любого контекста при помощи нужного модификатора.

### Контекст по умолчанию

*   **Внутри `defn|l` (правила)** по умолчанию все вызовы интерпретируются как **логические цели (`|l`)**.
*   **Внутри `defn` (функции) и в REPL** по умолчанию все вызовы считаются **вычислительными (`|f`)**.

### Модификаторы вызова

*   `|f` (function): Выполнить как обычный вызов функции. Возвращает одно скалярное значение.
*   `|l` (logic): Выполнить как логическую цель в **потоковом режиме**. Возвращает **ленивую последовательность кортежей-решений**. Каждый кортеж содержит полный набор связанных переменных для одного решения.
*   `|seq` (sequence): Выполнить как логическую цель, но **материализовать результат**. Движок собирает все решения в одну **ленивую последовательность** и связывает ее как единое целое с переменной.

### Примеры вызовов

**1. Вызов логики из обычного кода:**

Для поиска всех внуков "alice" не нужен специальный оператор. Достаточно вызвать правило с модификатором `|l`. Символ `_` используется как плейсхолдер для обозначения "неизвестной", которую мы хотим найти.

```clojure
;; Запрос: (grandparent "alice" _)
;; Результат: '(["alice" "charlie"] ["alice" "david"]) - ленивая последовательность
(let [solutions (grandparent|l "alice" _)
      ;; Теперь solutions - обычная коллекция, с которой можно работать
      ;; стандартными функциями Clojure.
      grandchildren (map second solutions)]
  (println "Внуки Алисы:" grandchildren))
```

**2. Использование `|f` и `|seq` в правиле:**

```clojure
(defn|l child-count [parent count]
  ;; Вызываем `parent` в режиме `|seq`, чтобы связать
  ;; переменную `children` с ленивой последовательностью ВСЕХ детей.
  (let [children (parent|seq parent _)]
    ;; Теперь `children` — это обычная коллекция.
    ;; Применяем к ней `count`, явно указав режим `|f`.
    (= count (count|f children))))
```

## 7. База Знаний (KB)

**Определение:** **База Знаний ($KB$)** — это формально определенное множество всех **доказуемых основных термов**.

Это множество формируется Tipster-компилятором на основе всех `def` (фактов) и `defn|l` (правил), определенных в проекте.

## 8. Расширяемость

Архитектура с модификаторами легко расширяется. Например, можно ввести стратегии `|fl` (сначала функция, потом логика) и `|lf` (сначала логика, потом функция), просто научив компилятор новым семантикам.
