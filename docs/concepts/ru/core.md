# Ключевые концепции Tipster

## 1. Введение

Этот документ закладывает формальный фундамент для ключевых концепций проекта Tipster. Его цель — служить каноническим источником, определяя основные строительные блоки системы с математической и семантической строгостью.

## 2. Базовая терминология: Атом и Символ

Во избежание путаницы, возникающей на стыке логического программирования (в духе Prolog) и Clojure, необходимо четко определить базовые термины.

*   **Символ (Symbol):** В Clojure `Symbol` — это идентификатор, который обычно ссылается на что-либо (например, на функцию или переменную). В Tipster, следуя этой семантике, мы используем символы для обозначения функторов, переменных и других логических конструкций. Это понятие наиболее близко к тому, что в Prolog называется **атомом** (atom) — уникальной символьной константой.

*   **Атом (Atom):** В Clojure `Atom` — это специфический ссылочный тип данных, используемый для управления синхронным, не координированным изменением состояния. **В документации Tipster этот термин не используется**, чтобы избежать путаницы с его прологовским омонимом. Для обозначения символьных констант мы используем термин **Символ**.

## 3. Терм в Tipster

В Tipster, как и в классическом логическом программировании, **терм** — это базовая структура данных. Структурно терм может быть одним из трех:

1.  **Константа:** Неизменяемое значение. Константами могут быть:
    *   **Символы** (в значении, определенном ранее, например, `some-name`)
    *   Числа (например, `42`)
    *   Строки (например, `"hello"`)
2.  **Переменная:** Идентификатор, который может быть связан с другим термом в процессе унификации (например, `X`, `Person`).
3.  **Составной терм:** Структура вида `(f t₁ ... tₙ)`, где `f` — это имя, называемое **функтором**, а `t₁ ... tₙ` — это термы, являющиеся его аргументами (например, `(point X 1)`). Более строгое определение функтора, раскрывающее его семантику в Tipster, приведено ниже.

Ключевое отличие и расширение понятия в Tipster заключается в его **двойной семантике**.

**Определение (Двойная семантика терма):**

Каждый **терм** в Tipster — это синтаксическая конструкция, которая может быть подвергнута двум различным, но взаимосвязанным видам интерпретации:

1.  **Логическая интерпретация ($Φ_L$)**: В этом контексте терм рассматривается как **логический образец** для унификации и поиска. Интерпретация $Φ_L(t, B) → S$ отображает терм $t$ и набор текущих привязок переменных $B$ в поток (возможно, бесконечный) наборов решений $S$, где каждое решение — это новый набор привязок.
2.  **Вычислительная интерпретация ($Φ_C$)**: В этом контексте терм рассматривается как **вычислительное выражение**, которое необходимо исполнить. Интерпретация $Φ_C(t, C) → v$ отображает терм $t$ и контекст вычисления $C$ в одно результирующее значение $v$.

## 4. Основной терм (Ground Term)

Прежде чем двигаться дальше, необходимо ввести одно из ключевых понятий логического программирования.

**Определение (Основной терм):**

**Основной терм** (англ. *Ground Term*) — это терм, **не содержащий переменных**. Он состоит исключительно из функторов и констант. Такие термы представляют собой конкретные, полностью определенные данные.

*   **Примеры основных термов:**
    *   `"alice"` (константа)
    *   `42` (константа)
    *   `(location "Paris" "France")` (составной терм, все аргументы — константы)

**Определение (Неосновной терм):**

**Неосновной (или переменный) терм** — это терм, который содержит хотя бы одну переменную. Такие термы служат в качестве образцов или запросов в процессе логического вывода.

*   **Примеры неосновных термов:**
    *   `X` (переменная)
    *   `(location City "France")` (составной терм с переменной `City`)

Далее в документе, говоря об "истинных термах" в контексте фактов и предикатов, мы будем иметь в виду именно **основные термы**.

## 5. Функтор в Tipster

В Prolog функтор — это просто маркер, определяющий имя и арность (количество аргументов) составного терма, например, `person/2`.

В Tipster функтор — это фундаментальное звено, связывающее логический и вычислительный миры.

**Определение (Функтор):**

В Tipster **функтор** — это именованная сущность с фиксированной арностью (количеством аргументов), которая обладает **двойной семантикой**.

Это означает, что для каждого функтора $f$ существуют две связанные с ним сущности:

*   **Логический предикат ($P_f$):** В Tipster это понятие трактуется в соответствии с традициями логического программирования, а не как его аналог в императивных языках. Предикат — это не просто функция, возвращающая `true` или `false`; $P_f$ — это **механизм, определяющий множество всех истинных основных термов** (ground terms) для данного функтора.
    *   **Истинность основного терма:** Основной терм `(f c₁ ... cₙ)` считается **истинным**, если он принадлежит множеству, определяемому предикатом $P_f$. В противном случае он считается **ложным**.
    *   **Реализация:** На практике, в Clojure, это множество не хранится в памяти целиком. Вместо этого, предикат $P_f$ реализуется как **генератор** (в виде ленивой последовательности), который по запросу производит элементы этого множества. Каждый элемент последовательности — это один истинный основной терм (одно "решение"). Порядок элементов в последовательности зависит от стратегии логического вывода.

*   **Вычислительная функция ($C_f$):** Это стандартная функция Clojure, которая принимает $n$ аргументов и возвращает некоторое вычисленное значение. Она используется в обычном исполнении кода.

Таким образом, функтор — это не просто имя структуры, а **имя дуальной сущности**. Когда система встречает составной терм `(f t₁ ... tₙ)`, она, в зависимости от контекста, применяет к его аргументам либо логический предикат $P_f$, либо вычислительную функцию $C_f$.

## 6. Декларация предиката

Для того чтобы система Tipster могла работать с функтором, он должен быть явно объявлен.

**Определение (Декларация предиката):**

**Декларация предиката** — это каноническая синтаксическая конструкция для определения функтора в коде. Она устанавливает его имя и арность (сигнатуру) и регистрирует его как логическую сущность в системе.

В Tipster для этого используется макрос `defpredicate`:
```clojure
(defpredicate parent [person child])
```
*   `defpredicate` — это макрос, который сообщает системе, что `parent` является функтором.
*   Сигнатура `[person child]` определяет арность функтора (в данном случае, 2) и служит для документации.

Эта декларация не создает исполняемого кода, но является необходимым шагом, который позволяет системе в дальнейшем распознавать факты и правила, определяющие логический предикат $P_{\text{parent}}$.

## 7. Факт (Утверждение)

**Определение (Факт):**

**Факт** (или **утверждение**) — это безусловное определение истинности предиката для конкретных основных термов. Это объявление того, что отношение, обозначаемое функтором, выполняется для данных констант.

Формальная запись: $P_f(c_1, c_2, ..., c_n)$

Пример: `(parent "alice" "bob")` — это факт, который утверждает, что предикат $P_{\text{parent}}$ истинен для констант `"alice"` и `"bob"`.

**Реализация в Tipster:**

В Tipster утверждение факта выглядит как вызов функции, имя которой совпадает с именем ранее декларированного предиката.

```clojure
;; 1. Декларация предиката с помощью макроса
(defpredicate parent [person child])

;; 2. Утверждение фактов как вызовов предиката
(parent "alice" "bob")
(parent "alice" "charlie")
```
Здесь вызовы `(parent ...)` не исполняются как вычислительный код. Поскольку `parent` был зарегистрирован как предикат, система Tipster распознает эти вызовы как факты и добавляет соответствующие основные термы в $KB$ для определения предиката $P_{\text{parent}}$.

## 8. Правило

**Определение (Правило):**

**Правило** — это условное определение истинности предиката. Оно утверждает, что предикат для заданных термов (заголовка правила) истинен, *если* истинна конъюнкция других предикатов (тела правила).

Формальная запись: $P_f(t_1, ..., t_n) \leftarrow P_{g_1}(...), ..., P_{g_k}(...)$

Пример: Правило `grandparent` определяет, что предикат $P_{\text{grandparent}}$ истинен для термов $X$ и $Z$, если найдется такой терм $Y$, для которого истинны предикаты $P_{\text{parent}}(X, Y)$ и $P_{\text{parent}}(Y, Z)$. В чуждом для Clojure синтаксисе Prolog это выглядело бы так: `grandparent(X, Z) :- parent(X, Y), parent(Y, Z)`.

**Пример (Двойная семантика правила):**

В Tipster, в соответствии с его видением двойной семантики, правило определяется как стандартная функция Clojure. Важно, что имя этой функции должно совпадать с именем предиката, который был ранее **декларирован** с помощью `defpredicate`.

```clojure
;; 1. Декларация предиката, определяющая его сигнатуру
(defpredicate grandparent [person grandchild])

;; 2. Определение правила как функции, реализующей этот предикат
(defn grandparent [X Z]
  (and
    (parent X Y)
    (parent Y Z)
    [X Z]))
```

Разберем эту конструкцию:
*   Сначала `defpredicate` объявляет `grandparent` как логический предикат с арностью 2.
*   Затем `defn` предоставляет **логическую реализацию** для этого предиката. Tipster понимает, что это не обычная функция, а определение правила, потому что имя `grandparent` уже зарегистрировано как предикат.
*   При **логической интерпретации ($Φ_L$)**, тело функции `(and ...)` становится телом правила.
*   При **вычислительной интерпретации ($Φ_C$)**, это может быть использовано для проверки конкретных значений.

Эта связка `defpredicate` (декларация) и `defn` (реализация) позволяет четко разделить сигнатуру предиката и его логику, полностью реализуя принцип двойной семантики.

## 9. База Знаний (Knowledge Base, KB)

**Определение (База Знаний):**

**База Знаний ($KB$)** — это формально определенное множество, состоящее из всех **основных термов**, которые считаются истинными в системе. Эти термы представляют собой факты, явно добавленные в систему.

Пример:

Если в систему добавлены факты:
```clojure
(parent "alice" "bob")
(parent "alice" "charlie")
```
То База Знаний $KB$ будет содержать два основных терма:
$$
KB = \{ \text{(parent "alice" "bob")}, \text{(parent "alice" "charlie")} \}
$$
Правила не добавляют термы в $KB$ напрямую, но используются в процессе логического вывода для получения новых, производных фактов из уже существующих в $KB$.
