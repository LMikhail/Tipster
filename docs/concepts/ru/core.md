# Ключевые концепции Tipster

## 1. Введение

Этот документ закладывает формальный фундамент для ключевых концепций проекта Tipster. Его цель — служить каноническим источником, определяя основные строительные блоки системы с математической и семантической строгостью.

В основе Tipster лежит **компилятор**, который транслирует высокоуровневый декларативный код, написанный как **бесшовный суперсет Clojure**, в эффективный исполняемый код.

## 2. Базовая терминология и структура термов

Во избежание путаницы, возникающей на стыке логического программирования (в духе Prolog) и Clojure, необходимо четко определить базовые термины.

*   **Символ (Symbol):** В Clojure `Symbol` — это идентификатор, который обычно ссылается на что-либо (например, на функцию или переменную). В Tipster, следуя этой семантике, мы используем символы для обозначения функторов, переменных и других логических конструкций. Это понятие наиболее близко к тому, что в Prolog называется **атомом** (atom) — уникальной символьной константой.

*   **Атом (Atom):** В Clojure `Atom` — это специфический ссылочный тип данных, используемый для управления синхронным, не координированным изменением состояния. **В документации Tipster этот термин не используется**, чтобы избежать путаницы с его прологовским омонимом. Для обозначения символьных констант мы используем термин **Символ**.

## 3. Терм

В Tipster, как и в классическом логическом программировании, **терм** — это базовая структура данных.

### Структура терма

Структурно терм может быть одним из трех:

1.  **Константа:** Неизменяемое значение. Константами могут быть:
    *   **Символы** (в значении, определенном ранее, например, `some-name`)
    *   Числа (например, `42`)
    *   Строки (например, `"hello"`)
2.  **Переменная:** Идентификатор, который может быть связан с другим термом в процессе унификации (например, `X`, `Person`).
3.  **Составной терм:** Структура вида `(f t₁ ... tₙ)`, где `f` — это имя, называемое **функтором**, а `t₁ ... tₙ` — это термы, являющиеся его аргументами (например, `(point X 1)`). Более строгое определение функтора, раскрывающее его семантику в Tipster, приведено ниже.

### Двойная семантика терма

Ключевое отличие и расширение понятия в Tipster заключается в его **двойной семантике**. Каждый терм — это синтаксическая конструкция, которая может быть подвергнута двум различным, но взаимосвязанным видам интерпретации:

1.  **Логическая интерпретация ($Φ_L$)**: Терм рассматривается как **логический образец** для унификации и поиска. Интерпретация $Φ_L(t, B) → S$ отображает терм $t$ и набор текущих привязок переменных $B$ в поток (возможно, бесконечный) наборов решений $S$.
2.  **Вычислительная интерпретация ($Φ_C$)**: Терм рассматривается как **вычислительное выражение**, которое необходимо исполнить. Интерпретация $Φ_C(t, C) → v$ отображает терм $t$ и контекст вычисления $C$ в одно результирующее значение $v$.

## 4. Основной терм (Ground Term)

**Определение:**

**Основной терм** (англ. *Ground Term*) — это терм, **не содержащий переменных**. Он состоит исключительно из функторов и констант. Такие термы представляют собой конкретные, полностью определенные данные.

*   **Примеры основных термов:** `42`, `"alice"`, `(location "Paris" "France")`.
*   **Примеры неосновных термов** (содержащих переменные): `X`, `(location City "France")`.

Далее в документе, говоря об "истинных термах" в контексте фактов и предикатов, мы будем иметь в виду именно **основные термы**.

## 5. Определение сущностей: `def` и `defn`

Архитектура Tipster элегантно разделяет определения на два типа: **констатации** (`def`) и **вычислительные абстракции** (`defn`).

### Факты (`def`)

**Определение:** **Факт** — это безусловное, декларативное утверждение о том, что некоторое отношение является истинным для данных **основных термов**.

**Реализация в Tipster:** Факт определяется с помощью `def`, аргументом которого является основной терм. Это синтаксически подчеркивает его природу как неизменяемой констатации.

```clojure
(def (parent "alice" "bob"))
(def (parent "alice" "charlie"))
```

### Правила и Функции (`defn`)

**Определение:** И правила, и функции являются **вычислительными абстракциями** — они принимают аргументы и производят результат. Поэтому для их определения используется единый, канонический для Clojure оператор `defn`.

**Реализация в Tipster:** Чтобы компилятор мог отличить правило от функции, используется **модификатор определения `::l`** (logic).

*   `(defn::l ...)` определяет **Правило**. Компилятор преобразует его в многозначную функцию, возвращающую ленивую последовательность решений.
*   `(defn ...)` (без модификатора) определяет стандартную **Функцию** Clojure.

Это позволяет определять предикат и одноименную вычислительную функцию без каких-либо конфликтов:

```clojure
;; ПРАВИЛО (реализация предиката P_grandparent)
(defn::l grandparent [?x ?z]
  (parent ?x ?y)
  (parent ?y ?z))

;; ФУНКЦИЯ (реализация вычислительной функции C_grandparent)
(defn grandparent [x z]
  (println "Вызвана быстрая проверка!")
  ; ... код быстрой проверки по графу в памяти ...
)
```

## 6. Вызов и взаимодействие миров

Ключевая инновация Tipster — управление семантикой вызова через **явные модификаторы**. Поскольку Tipster — это суперсет Clojure, нет нужды в специальных "шлюзах" или API. Любая сущность может быть вызвана из любого контекста при помощи нужного модификатора.

### Контекст по умолчанию

*   **Внутри `defn::l` (правила)** по умолчанию все вызовы интерпретируются как **логические цели (`::l`)**.
*   **Внутри `defn` (функции) и в REPL** по умолчанию все вызовы считаются **вычислительными (`::f`)**.

### Модификаторы вызова

*   `::f` (function): Выполнить как обычный вызов функции. Возвращает одно скалярное значение.
*   `::l` (logic): Выполнить как логическую цель в **потоковом режиме**. Возвращает **ленивую последовательность кортежей-решений**. Каждый кортеж содержит полный набор связанных переменных для одного решения.
*   `::seq` (sequence): Выполнить как логическую цель, но **материализовать результат**. Движок собирает все решения в одну **ленивую последовательность** и связывает ее как единое целое с переменной.

### Примеры вызовов

**1. Вызов логики из обычного кода:**

Для поиска всех внуков "alice" не нужен специальный оператор. Достаточно вызвать правило с модификатором `::l`. Символ `_` используется как плейсхолдер для обозначения "неизвестной", которую мы хотим найти.

```clojure
;; Запрос: (grandparent "alice" _)
;; Результат: '(["alice" "charlie"] ["alice" "david"]) - ленивая последовательность
(let [solutions (grandparent::l "alice" _)
      ;; Теперь solutions - обычная коллекция, с которой можно работать
      ;; стандартными функциями Clojure.
      grandchildren (map second solutions)]
  (println "Внуки Алисы:" grandchildren))
```

**2. Использование `::f` и `::seq` в правиле:**

```clojure
(defn::l child-count [?parent ?count]
  ;; Вызываем `parent` в режиме `::seq`, чтобы связать
  ;; переменную `children` с ленивой последовательностью ВСЕХ детей.
  (let [children (parent::seq ?parent _)]
    ;; Теперь `children` — это обычная коллекция.
    ;; Применяем к ней `count`, явно указав режим `::f`.
    (= ?count (count::f children))))
```

## 7. База Знаний (KB)

**Определение:** **База Знаний ($KB$)** — это формально определенное множество всех **доказуемых основных термов**.

Это множество формируется Tipster-компилятором на основе всех `def` (фактов) и `defn::l` (правил), определенных в проекте.

## 8. Расширяемость

Архитектура с модификаторами легко расширяется. Например, можно ввести стратегии `::fl` (сначала функция, потом логика) и `::lf` (сначала логика, потом функция), просто научив компилятор новым семантикам.
