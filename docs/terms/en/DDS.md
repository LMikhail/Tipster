# Terms Module Detailed Design Specification (DDS)

### Architecture Overview

#### Protocol Definition
```clojure
(defprotocol ITerm
  (term-type [this])      ; Returns :variable, :atom, or :compound
  (term-value [this])     ; Returns the actual value
  (is-variable? [this])   ; Returns true for variables
  (is-compound? [this]))  ; Returns true for compound terms
```

#### Data Structures
1. **Variable**
   ```clojure
   (defrecord Variable [name id]
     ITerm
     (term-type [_] :variable)
     (term-value [this] this)
     (is-variable? [_] true)
     (is-compound? [_] false))
   ```
   - `name`: String identifier for the variable
   - `id`: Unique identifier generated by `gensym`

2. **Atom**
   ```clojure
   (defrecord Atom [value]
     ITerm
     (term-type [_] :atom)
     (term-value [this] (:value this))
     (is-variable? [_] false)
     (is-compound? [_] false))
   ```
   - `value`: Any Clojure value

3. **Compound**
   ```clojure
   (defrecord Compound [functor args]
     ITerm
     (term-type [_] :compound)
     (term-value [this] this)
     (is-variable? [_] false)
     (is-compound? [_] true))
   ```
   - `functor`: Symbol representing the term's function
   - `args`: Vector of arguments (other terms)

### Core Functions

#### Term Creation
```clojure
(defn make-variable [name] (->Variable name (gensym name)))
(defn make-atom [value] (->Atom value))
(defn make-compound [functor & args] (->Compound functor (vec args)))
```

#### Type Conversion
```clojure
(defn auto-convert-term [term]
  (if (satisfies? ITerm term)
    term
    (clojure-term->tipster-term term)))

(defn clojure-term->tipster-term [data]
  (cond
    (satisfies? ITerm data) data
    (symbol? data) (if (.startsWith (name data) "?")
                     (make-variable (subs (name data) 1))
                     (make-atom data))
    (list? data) (if (empty? data)
                   (make-atom data)
                   (apply make-compound (first data) 
                          (map clojure-term->tipster-term (rest data))))
    (vector? data) (apply make-compound 'vector 
                         (map clojure-term->tipster-term data))
    :else (make-atom data)))

(defn tipster-term->clojure-term [term bindings deref-fn]
  (let [deref-term (deref-fn term bindings)
        converted-term (auto-convert-term deref-term)]
    (cond
      (is-variable? converted-term) 
      (symbol (str "?" (:name converted-term)))
      (is-compound? converted-term)
      (let [functor (:functor converted-term)
            args (map #(tipster-term->clojure-term % bindings deref-fn) 
                     (:args converted-term))]
        (if (= functor 'vector)
          (vec args)
          (cons functor args)))
      (satisfies? ITerm converted-term)
      (term-value converted-term)
      :else converted-term)))
```

### Implementation Details

1. **Variable Handling**
   - Variables are created with unique IDs using `gensym`
   - Variable names are preserved for debugging and display
   - Variables can be dereferenced using the provided `deref-fn`

2. **Type Conversion**
   - Automatic conversion from Clojure data structures
   - Special handling for variables (prefix '?')
   - Support for nested structures
   - Vector preservation through compound terms

3. **Performance Considerations**
   - Use of `defrecord` for efficient data structures
   - Vector-based compound terms for O(1) access
   - Minimal object creation during conversion 
